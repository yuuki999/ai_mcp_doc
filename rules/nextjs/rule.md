# NextJS & Reactの開発ルール

全般ルール:
  - 日本語で説明すること
  - npmではなくpnpmを使用すること

NextJS・React全体的なルール:
  アーキテクチャ:
    - app routerを前提に開発すること
    - 可能な限りServer Actionsを使用すること
    - フォーム管理にはzodとReact Hook Formを組み合わせること
    - UIコンポーネントはshadcn/uiの使用を推奨（必須ではないが適切な場面では使用）
  
  コード品質:
    - Unicodeエスケープされた文字を表示しないこと
    - 型定義ファイルはtypesディレクトリ配下にまとめること（適切な場合は更に細分化も可）
    - コンポーネントは適切な単位で分割し、巨大ファイルを避けること

NextJS・React詳細ルール:
  クライアント・サーバーコンポーネント:
    - "use client"を高すぎる位置に配置しない:
        問題: 親コンポーネントに安易に追加するとバンドルサイズ増大
        解決策: インタラクティブな要素を持つコンポーネントのみに追加し、ツリーの末端に近い部分で使用する
    
    - クライアントコンポーネントへのリファクタリング:
        問題: ページ全体をクライアントコンポーネント化しがち
        解決策: インタラクティブな部分だけを別コンポーネントに分離する
    
    - "use server"の誤用:
        問題: サーバーコンポーネント化に使ってしまう
        解決策: サーバーコンポーネントはデフォルトなので何もしなくてOK、server-onlyパッケージを使用する

    - クライアントコンポーネントの誤解:
        問題: クライアントだけで実行されると思い込む
        解決策: 初期レンダリング時にサーバーでも実行されるため、ブラウザAPIを使う場合は条件分岐かuseEffect内で使用する
        例: |
          function Component() {
            const [data, setData] = useState(null);
            
            useEffect(() => {
              // クライアントサイドでのみ実行される
              setData(localStorage.getItem('key'));
            }, []);
            
            return <div>{data}</div>;
          }
    
    - ハイドレーションエラー:
        問題: サーバーとクライアントのレンダリング結果が一致しない
        解決策: ブラウザ環境のチェックとクライアント側処理を適切に分離、suppressHydrationWarningは最終手段

  データフェッチ:
    - ルートハンドラーでのデータ取得:
        問題: API Routesを作成して取得すると非効率
        解決策: サーバーコンポーネント内で直接データフェッチを行う、API Routesは外部リクエスト用
    
    - データフェッチのウォーターフォール:
        問題: 複数データの順次フェッチでロード時間が長くなる
        解決策: |
          Promise.all()やPromise.allSettled()で並行フェッチを実装
          
          // 並行フェッチの例
          async function Page() {
            const [products, ratings] = await Promise.all([
              getProducts(),
              getRatings()
            ]);
            // 両方同時に開始、両方完了後に続行
          }
    
    - ミューテーション後のビュー更新:
        問題: キャッシュされた古いレンダリング結果が表示され続ける
        解決策: |
          revalidatePathまたはrevalidateTag関数でキャッシュを無効化
          
          // サーバーアクション内でキャッシュ再検証
          export async function addProduct(data) {
            await db.products.create(data);
            // 特定のパスのキャッシュを無効化
            revalidatePath('/products');
          }

  サーバーアクション:
    - サーバーコンポーネントへのデータ送信:
        問題: フォームのaction属性にサーバーコンポーネントを直接指定できない
        解決策: サーバーアクション（use serverディレクティブ付き関数）を使用する
    
    - サーバーアクションの使用範囲:
        問題: サーバーコンポーネントでしか使えないと誤解する
        解決策: クライアントコンポーネントからも直接インポート可能、useTransitionと組み合わせるとローディング状態も管理可能
    
    - サーバーアクションのセキュリティ:
        問題: バリデーションと保護不足
        解決策: Zodでデータをバリデーション、認証・認可のチェックを実施
    
    - "use server"の役割誤解:
        問題: サーバー専用の保証と考える
        解決策: サーバーアクション化するためのもの、コードをサーバー専用にするにはserver-onlyパッケージを使用

  ルーティングとレンダリング:
    - サーチパラメータの扱い:
        問題: 処理場所の誤り
        解決策: サーバーサイド処理が必要ならsearchParams prop、クライアントサイドならuseSearchParams hookを使う
    
    - ローディング状態:
        問題: 考慮不足
        解決策: loading.tsxファイルでページローディング中のUI表示を定義
    
    - Suspense境界:
        問題: 境界が粗すぎる
        解決策: データフェッチをする特定のコンポーネントだけをSuspenseでラップ
    
    - Suspenseの配置:
        問題: 間違った位置に配置
        解決策: 非同期処理を行うコンポーネントの親またはそれより上位に配置
    
    - Suspenseのkey prop:
        問題: 忘れがち
        解決策: パラメータ変更時に再トリガーするには変更する値をkey propに指定
    
    - Dynamic Rendering:
        問題: 意図せず発生
        解決策: searchParams、cookies、headersなどのAPI使用を最小限に、認証チェックはMiddlewareで検討

  セキュリティとベストプラクティス:
    - シークレット管理:
        問題: ハードコード
        解決策: 環境変数として管理、process.env.SECRET_KEYでアクセス、クライアント公開が必要な場合のみNEXT_PUBLIC_接頭辞を使用
    
    - ユーティリティ区分:
        問題: クライアント/サーバーの区別不足
        解決策: server-onlyパッケージの使用、ファイル名も明確に（例：serverUtils.ts）
    
    - redirect関数:
        問題: try/catch内で使用
        解決策: try/catchブロックの外側で使用、サードパーティ認証ライブラリでも同様の問題が発生する可能性あり